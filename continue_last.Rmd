
make a new season's ratings by continuing from last season

## packages

```{r}
library(tidyverse)
library(conflicted)
library(iso.week.half)
conflict_prefer("filter", "dplyr")
source("cleaning.R")
```

function to get latest ratings

```{r}
get_post <- function() {
  read_rds("wpost.rds")
}

latest_2 <- function(league_name, post_rat) {
  post_rat %>% filter(league==league_name) %>% 
    unnest(post) %>% 
    select(team, rating, h)
}

latest_1 <- function(league_name) {
  post <- get_post()
  latest_2(league_name, post)
}

clean_new_names <- function(games, new_leagues) {
  games %>% filter(comp %in% new_leagues) %>% 
    clean_names()
}

```

test out

```{r}
latest_1("ukraine")
```

gimme a vector of new league ids and get the clean names


```{r}
name <- "czech republic"
new <- c(54505, 54510)
old_ratings <- latest_1(name)
new_names <- clean_new_names(games, new)
old_ratings %>% anti_join(new_names, by=c("team"="name")) # teams not in new_names
new_names %>% anti_join(old_ratings, by=c("name"="team")) # teams in new_names without rating

```

want the teams in new_names that are *not* in old_ratings




## jottings

these are final ratings for 54067, so use as initial ratings for 54066-54068.

idea: if current "last" exists as this, get ratings from there, else do old initialization

or: make two rows of data file and combine into list-column

```{r}
d <- tribble(
  ~a, ~b,
  47821, 54067,
  54067, 54066,
  54067, 54068
)
d
```

```{r}
d %>% nest(bb=b) %>% 
  pull(bb)
```

so clean!

```{r}
games %>% filter(comp %in% c(54066, 54068)) %>% 
  clean_names() -> dd
dd
```

```{r}
dd %>% left_join(d, by=c("name"="team"))
```

get new teams (if any) and do like initializing.Rmd

leagues to check

ukraine
austria
armenia
croatia
greece
denmark
poland?
slovakia 

in codes.csv, repeat regular season with each playoff section, then nest this season col when reading in. Deal with consequences, eg first element of list, %in% vs ==, etc.