
make a new season's ratings by continuing from last season

## packages

```{r}
library(tidyverse)
library(conflicted)
conflict_prefer("filter", "dplyr")
source("cleaning.R")
```

function to get latest ratings

```{r}
get_post <- function() {
  read_rds("wpost.rds")
}

latest_2 <- function(league_name, post_rat) {
  post_rat %>% filter(league==league_name) %>% 
    unnest(post) %>% 
    select(team, rating, h)
}

latest_1 <- function(league_name) {
  post <- get_post()
  latest_2(league_name, post)
}

clean_new_names <- function(games, new_leagues) {
  games %>% filter(comp %in% new_leagues) %>% 
    clean_names()
}

```

test out

```{r}
latest_1("ukraine")
```

gimme a vector of new league ids and get the clean names

```{r}
new <- c(54066, 54068)
clean_new_names(games, new)
```

```{r}
name <- "ukraine"
new <- c(54066, 54068)
old_ratings <- latest_1(name)
new_names <- clean_new_names(games, new)
old_ratings %>% left_join(new_names, by=c("team"="name"))
```

use this as the basis for new ratings

do I need to do it the other way around (in case of new teams or to keep old ones)?



## jottings

these are final ratings for 54067, so use as initial ratings for 54066-54068.

idea: if current "last" exists as this, get ratings from there, else do old initialization

or: make two rows of data file and combine into list-column

```{r}
d <- tribble(
  ~a, ~b,
  47821, 54067,
  54067, 54066,
  54067, 54068
)
d
```

```{r}
d %>% nest(bb=b) %>% 
  pull(bb)
```

so clean!

```{r}
games %>% filter(comp %in% c(54066, 54068)) %>% 
  clean_names() -> dd
dd
```

```{r}
dd %>% left_join(d, by=c("name"="team"))
```

get new teams (if any) and do like initializing.Rmd

leagues to check

ukraine
austria
armenia
croatia
greece
denmark
poland?
slovakia 

in codes.csv, repeat regular season with each playoff section, then nest this season col when reading in. Deal with consequences, eg first element of list, %in% vs ==, etc.